<html><head><title>Flattened Net and PuzzleGeometry</title>
<script src="PuzzleGeometry.js"></script>
<script>
function parseDesc(s) {
   var a = s.split(/ /).filter(Boolean) ;
   if (a.length % 2 == 0)
      return false ;
   if (a[0] != 'o' && a[0] != 'c' && a[0] != 'i' && a[0] != 'd' && a[0] != 't')
      return false ;
   var r = [] ;
   for (var i=1; i<a.length; i += 2) {
      if (a[i] != 'f' && a[i] != 'v' && a[i] != 'e')
         return false ;
      r.push([a[i], a[i+1]]) ;
   }
   return [a[0], r] ;
}
var lastval ;
var textinput ;
var distance ;
var pg ;
function checkchange() {
   var s = textinput.value ;
   if (s == lastval)
      return ;
   lastval = s ;
   var p = parseDesc(s) ;
   if (p) {
      pg = new PuzzleGeometry(p[0], p[1]) ;
      pg.allstickers() ;
      myfaces = pg.getfaces() ;
      distance = pg.vertexdistance * 3 ;
      var desc =
         "Faces " + pg.baseplanerot.length + "<BR>" +
         "Stickers per face " + pg.stickersperface + "<BR>" +
         "Cubies " + pg.cubies.length + "<BR>" +
         "Short edge " + pg.shortedge + "<BR>" +
         "Edge distance " + pg.edgedistance + "<BR>" +
         "Vertex distance " + pg.vertexdistance + "<BR>" ;
      document.getElementById('data').innerHTML = desc ;
      pg.genperms() ;
      display() ;
   }
}
function doselection(el) {
   if (el.target.value != '') {
      textinput.value = el.target.value ;
      checkchange() ;
   }
}
var puz = null ;
// This is a description of the nets and the external names we give each
// face.  The names should be single-character upper-case alpahbetics so
// we can easily also name and distinguish vertices and edges, but we
// may change this in the future.  The nets consist of a list of lists.
// Each list gives the name of a face, and then the names of the
// faces connected to that face (in the net) in clockwise order.
// The length of each list should be one more than the number of
// edges in the regular polygon for that face.  All polygons must
// have the same number of edges.
// The first two faces in the first list must describe a horizontal edge
// that is at the bottom of a regular polygon.  The first two faces in
// every subsequent list for a given polytope must describe a edge that
// is directly connected in the net and has already been described (this
// sets the location and orientation of the polygon for that face.
// Any edge that is not directly connected in the net should be given
// the empty string as the other face.  All faces do not need to have
// a list starting with that face; just enough to describe the full
// connectivity of the net.

var nets = {
4: // four faces: tetrahedron
[
   ["F", "D", "L", "R"],
],
6: // six faces: cube
[
   ["F", "D", "L", "U", "R"],
   ["R", "F", "", "B", ""],
],
8: // eight faces: octahedron
[
   ["F", "D", "L", "R"],
   ["D", "F", "N", ""],
   ["N", "D", "", "B"],
   ["B", "N", "U", "M"],
],
12: // twelve faces:  dodecahedron
[
   ["U", "F", "", "", "", ""],
   ["F", "U", "R", "C", "A", "L"],
   ["R", "F", "", "", "E", ""],
   ["E", "R", "", "B", "", ""],
   ["B", "E", "G", "H", "I", "D"],
],
20: // twenty faces: icosahedron
[
   ["R", "C", "F", "E"],
   ["F", "R", "L", "U"],
   ["L", "F", "A", ""],
   ["E", "R", "G", "I"],
   ["I", "E", "S", "H"],
   ["S", "I", "J", "B"],
   ["B", "S", "K", "D"],
   ["K", "B", "M", "O"],
   ["O", "K", "P", "N"],
   ["P", "O", "Q", ""],
],
} ;
// the colors should use the same naming convention as the nets, above.
var colors = {
4: { F: '#ffffff', D: '#ff0000', L: '#00ff00', R: '#0000ff', },
6: { U: '#ffffff', F: '#00ff00', R: '#ff0000',
     D: '#ffff00', B: '#0000ff', L: '#ff8000', },
8: { U: '#e085b9', F: '#080d99', R: '#c1e35c', D: '#22955e',
     B: '#9121ab', L: '#b27814', M: '#0d35ad', N: '#eb126b', },
12: { U: '#b62d67', F: '#769500', R: '#88132b', C: '#d9af2f',
      A: '#fc74d7', L: '#d7b6f1', E: '#ee53b9', B: '#75f491',
      G: '#ab5947', H: '#ce5a57', I: '#f09e4f', D: '#0d24c0', },
20: { R: '#db69f0', C: '#178fde', F: '#23238b', E: '#9cc726',
      L: '#2c212d', U: '#177fa7', A: '#e0de7f', G: '#2b57c0',
      I: '#41126b', S: '#4b8c28', H: '#7c098d', J: '#7fe7b4',
      B: '#85fb74', K: '#3f4bc3', D: '#0ff555', M: '#f1c2c8',
      O: '#58d340', P: '#c514f2', N: '#14494e', Q: '#8b1be1', }} ;
// given a single edge describing a regular polygon with polyn sides,
// extend it around.
function extendedges(a, polyn) {
   var dx = a[1][0] - a[0][0] ;
   var dy = a[1][1] - a[0][1] ;
   var ang = 2*Math.PI/polyn ;
   var cosa = Math.cos(ang) ;
   var sina = Math.sin(ang) ;
   for (var i=2; i<polyn; i++) {
      var ndx = dx * cosa + dy * sina ;
      dy = dy * cosa - dx * sina ;
      dx = ndx ;
      a.push([a[i-1][0]+dx, a[i-1][1]+dy]) ;
   }
}
function drawedges(context, pts, color) {
   context.beginPath() ;
   context.moveTo(pts[0][0], pts[0][1]) ;
   for (var i=1; i<pts.length; i++)
      context.lineTo(pts[i][0], pts[i][1]) ;
   context.closePath() ;
   context.save() ;
   context.fillStyle = color ;
   context.fill() ;
   context.restore() ;
   context.stroke() ;
}
// Find a net from a given face count.  Walk it, assuming we locate
// the first edge from (0,0) to (1,1) and compute the minimum and
// maximum vertex locations from this.  Then do a second walk, and
// assign the actual geometry.
function walknet(pg, fn, context, w, h) {
   var net = nets[fn] ;
   if (net == null) {
      alert("No net for " + fn + " faces.") ;
      return ;
   }
   var polyn = net[0].length - 1 ;
   var edges = {} ;
   var minx = 0 ;
   var miny = 0 ;
   var maxx = 1 ;
   var maxy = 0 ;
   edges[net[0][0]] = [[1, 0], [0, 0]] ;
   extendedges(edges[net[0][0]], polyn) ;
   for (var i=0; i<net.length; i++) {
      var f0 = net[i][0] ;
      if (!edges[f0]) {
         alert("Bad edge description; first edge not connected.") ;
         return ;
      }
      for (var j=1; j<net[i].length; j++) {
         var f1 = net[i][j] ;
         if (f1 == "" || edges[f1])
            continue ;
         edges[f1] = [edges[f0][j%polyn], edges[f0][(j+polyn-1)%polyn]] ;
         extendedges(edges[f1], polyn) ;
      }
   }
   for (var f0 in edges) {
      var es = edges[f0] ;
      for (var i=0; i<es.length; i++) {
         minx = Math.min(minx, es[i][0]) ;
         maxx = Math.max(maxx, es[i][0]) ;
         miny = Math.min(miny, es[i][1]) ;
         maxy = Math.max(maxy, es[i][1]) ;
      }
   }
   var sc = Math.min(w/(maxx-minx), h/(maxy-miny)) ;
   var xoff = 0.5*(w-sc*(maxx+minx)) ;
   var yoff = 0.5*(h-sc*(maxy+miny)) ;
   var geos = {} ;
   var netgeo = {} ;
   var geonet = {} ;
   var bg = pg.getboundarygeometry() ;
   edges2 = {} ;
   var initv = [[sc+xoff, yoff], [xoff, yoff]] ;
   edges2[net[0][0]] = initv ;
   extendedges(edges2[net[0][0]], polyn) ;
   netgeo[net[0][0]] = bg.facenames[0][1] ;
   geonet[bg.facenames[0][1]] = net[0][0] ;
   geos[bg.facenames[0][1]] = pg.project2d(0, 0,
                 [Quat(0, initv[0][0], initv[0][1], 0),
                  Quat(0, initv[1][0], initv[1][1], 0)]) ;
   var connectat = [] ;
   connectat[0] = 0 ;
   for (var i=0; i<net.length; i++) {
      var f0 = net[i][0] ;
      if (!edges2[f0]) {
         alert("Bad edge description; first edge not connected.") ;
         return ;
      }
      var gf0 = netgeo[f0] ;
      var gfi = -1 ;
      for (var j=0; j<bg.facenames.length; j++)
         if (gf0 == bg.facenames[j][1]) {
            gfi = j ;
            break ;
         }
      if (gfi < 0) {
         alert("Could not find first face name " + gf0) ;
         return 0 ;
      }
      var thisface = bg.facenames[gfi][0] ;
      for (var j=1; j<net[i].length; j++) {
         var f1 = net[i][j] ;
         if (f1 == "" || edges2[f1])
            continue ;
         edges2[f1] = [edges2[f0][j%polyn], edges2[f0][(j+polyn-1)%polyn]] ;
         extendedges(edges2[f1], polyn) ;
         // what edge are we at?
         var caf0 = connectat[gfi] ;
         var mp = thisface[(caf0+j)%polyn].sum(thisface[(caf0+j+polyn-1)%polyn]).smul(0.5) ;
         var epi = pg.findelement(bg.edgenames, mp) ;
         var edgename = bg.edgenames[epi][1] ;
         var gf1 = edgename[(gf0 == edgename[0]) ? 1 : 0] ;
         var gf1i = -1 ;
         for (var k=0; k<bg.facenames.length; k++) {
            if (gf1 == bg.facenames[k][1]) {
               gf1i = k ;
               break ;
            }
         }
         if (gf1i < 0) {
            alert("Could not find second face name") ;
            return 0 ;
         }
         netgeo[f1] = gf1 ;
         geonet[gf1] = f1 ;
         var otherface = bg.facenames[gf1i][0] ;
         for (var k=0; k<otherface.length; k++) {
            var mp2 = otherface[k].sum(otherface[(k+1)%polyn]).smul(0.5) ;
            if (mp2.dist(mp) <= eps) {
               var p1 = edges2[f0][(j+polyn-1)%polyn] ;
               var p2 = edges2[f0][j % polyn] ;
               connectat[gf1i] = k ;
               geos[gf1] = pg.project2d(gf1i, k,
                       [Quat(0, p2[0], p2[1], 0), Quat(0, p1[0], p1[1], 0)]) ;
               break ;
            }
         }
      }
   }
   // Let's build arrays for faster rendering.  We want to map from geo
   // base face number to color, and we want to map from geo face number
   // to 2D geometry.  These can be reused as long as the puzzle overall
   // orientation and canvas size remains unchanged.
   var pos = pg.getsolved() ;
   var colormap = [] ;
   var facegeo = [] ;
   for (var i=0; i<pg.basefacecount; i++)
      colormap[i] = colors[fn][geonet[pg.facenames[i][1]]] ;
   for (var i=0; i<pg.faces.length; i++) {
      var face = pg.faces[i] ;
      var facenum = Math.floor(i/pg.stickersperface) ;
      var g = geos[pg.facenames[facenum][1]] ;
      var face2 = face.map(function(p){
                       return [p.dot(g[0])+g[2].b, -p.dot(g[1])-g[2].c] ; }) ;
      facegeo.push(face2) ;
   }
   // Let's pretend we make a base move.
   var moveperms = pg.getmoveperms() ;
   if (moveperms.length) {
      for (var i=0; i<1; i++) {
         var rm = Math.floor(Math.random()*moveperms.length) ;
         pos = pos.rmul(Perm(moveperms[rm])) ;
      }
   }
   // Here's our final rendering call.
   for (var i=0; i<pg.faces.length; i++)
      drawedges(context, facegeo[i], colormap[pos.p[i]]) ;
   return geos ;
}
function display() {
   if (!pg)
      return ;
   var boundarygeo = pg.getboundarygeometry() ;
   var face0 = boundarygeo.facenames[0][0] ;
   var polyn = face0.length ; // number of vertices; 3, 4, or 5
   var canvas = document.getElementById("canvas");
   var context = canvas.getContext('2d');
   var trim = 10 ;
   context.save() ;
   context.clearRect(0, 0, canvas.width, canvas.height) ;
   var canwidth = canvas.width - 2 * trim ;
   var canheight = canvas.height - 2 * trim ;
   context.translate(trim, trim+canheight) ;
   try {
      walknet(pg, boundarygeo.facenames.length,
              context, canwidth, canheight) ;
   } finally {
      context.restore() ;
   }
}
function setup() {
   textinput = document.getElementById('desc') ;
   document.getElementById("puzzleoptions").onchange = doselection ;
   checkchange() ;
   setInterval(checkchange, 0.5) ;
}
</script>
</head>
<body onload="setup();">
Desc <input type=text id=desc value="c f 0.3333333333" size="50">
</input><br>
<select id="puzzleoptions">
<option value="">custom</option>
<option value="c f 0">2x2x2</option>
<option value="c f 0.333333333333333">3x3x3</option>
<option value="c f 0.5 f 0">4x4x4</option>
<option value="c f 0.6 f 0.2">5x5x5</option>
<option value="c f 0.666666666666667 f 0.333333333333333 f 0">6x6x6</option>
<option value="c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143">7x7x7</option>
<option value="c f 0.75 f 0.5 f 0.25 f 0">8x8x8</option>
<option value="c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111">9x9x9</option>
<option value="c f 0.8 f 0.6 f 0.4 f 0.2 f 0">10x10x10</option>
<option value="c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909">11x11x11</option>
<option value="c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0">12x12x12</option>
<option value="c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769">13x13x13</option>
<option value="c v 0">skewb</option>
<option value="c v 0.275">master skewb</option>
<option value="c v 0 v 0.38">professor skewb</option>
<option value="c e 0.707106781186547">helicopter</option>
<option value="c v 0.577350269189626">dino</option>
<option value="t v 0.333333333333333 v 1.66666666666667">pyraminx</option>
<option value="d f 0.7">megaminx</option>
<option value="d f 0.64 f 0.82">gigaminx</option>
<option value="d f 0">pentultimate</option>
<option value="d v 0.937962371425399">starminx</option>
<option value="d f 0.23606797749979">starminx 2</option>
<option value="d v 0">dodec star</option>
<option value="o f 0">skewb diamond</option>
<option value="o f 0.333333333333333">octahedron diamond</option>
<option value="i f 0">icosahedron skewb</option>
<option value="i v 0">icosahedron vskewb</option>
<option value="i v 0.18759247376021">icosahedron 2</option>
<option value="i v 0.18759247376021 e 0">icosahedron 3</option>
<option value="i v 0.84">icosahedron static faces</option>
<option value="i v 0.73">icosahedron moving faces</option>
</select>
<div id=data></div>
<canvas id="canvas" width=800 height=500>No canvas support?</canvas>
</body></html>
